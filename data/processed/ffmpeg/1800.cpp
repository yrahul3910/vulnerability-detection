static int smka_decode_frame(AVCodecContext *avctx, void *data,

                             int *got_frame_ptr, AVPacket *avpkt)

{

    SmackerAudioContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    GetBitContext gb;

    HuffContext h[4] = { { 0 } };

    VLC vlc[4]       = { { 0 } };

    int16_t *samples;

    uint8_t *samples8;

    int val;

    int i, res, ret;

    int unp_size;

    int bits, stereo;

    int pred[2] = {0, 0};



    if (buf_size <= 4) {

        av_log(avctx, AV_LOG_ERROR, "packet is too small\n");

        return AVERROR(EINVAL);

    }



    unp_size = AV_RL32(buf);



    if (unp_size > (1U<<24)) {

        av_log(avctx, AV_LOG_ERROR, "packet is too big\n");

        return AVERROR_INVALIDDATA;

    }



    init_get_bits(&gb, buf + 4, (buf_size - 4) * 8);



    if(!get_bits1(&gb)){

        av_log(avctx, AV_LOG_INFO, "Sound: no data\n");

        *got_frame_ptr = 0;

        return 1;

    }

    stereo = get_bits1(&gb);

    bits = get_bits1(&gb);

    if (stereo ^ (avctx->channels != 1)) {

        av_log(avctx, AV_LOG_ERROR, "channels mismatch\n");

        return AVERROR(EINVAL);

    }

    if (bits && avctx->sample_fmt == AV_SAMPLE_FMT_U8) {

        av_log(avctx, AV_LOG_ERROR, "sample format mismatch\n");

        return AVERROR(EINVAL);

    }



    /* get output buffer */

    s->frame.nb_samples = unp_size / (avctx->channels * (bits + 1));

    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");

        return ret;

    }

    samples  = (int16_t *)s->frame.data[0];

    samples8 =            s->frame.data[0];



    // Initialize

    for(i = 0; i < (1 << (bits + stereo)); i++) {

        h[i].length = 256;

        h[i].maxlength = 0;

        h[i].current = 0;

        h[i].bits = av_mallocz(256 * 4);

        h[i].lengths = av_mallocz(256 * sizeof(int));

        h[i].values = av_mallocz(256 * sizeof(int));

        skip_bits1(&gb);

        smacker_decode_tree(&gb, &h[i], 0, 0);

        skip_bits1(&gb);

        if(h[i].current > 1) {

            res = init_vlc(&vlc[i], SMKTREE_BITS, h[i].length,

                    h[i].lengths, sizeof(int), sizeof(int),

                    h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);

            if(res < 0) {

                av_log(avctx, AV_LOG_ERROR, "Cannot build VLC table\n");

                return AVERROR_INVALIDDATA;

            }

        }

    }

    if(bits) { //decode 16-bit data

        for(i = stereo; i >= 0; i--)

            pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16);

        for(i = 0; i <= stereo; i++)

            *samples++ = pred[i];

        for(; i < unp_size / 2; i++) {

            if(get_bits_left(&gb)<0)

                return AVERROR_INVALIDDATA;

            if(i & stereo) {

                if(vlc[2].table)

                    res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3);

                else

                    res = 0;

                if (res < 0) {

                    av_log(avctx, AV_LOG_ERROR, "invalid vlc\n");

                    return AVERROR_INVALIDDATA;

                }

                val  = h[2].values[res];

                if(vlc[3].table)

                    res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3);

                else

                    res = 0;

                if (res < 0) {

                    av_log(avctx, AV_LOG_ERROR, "invalid vlc\n");

                    return AVERROR_INVALIDDATA;

                }

                val |= h[3].values[res] << 8;

                pred[1] += sign_extend(val, 16);

                *samples++ = av_clip_int16(pred[1]);

            } else {

                if(vlc[0].table)

                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);

                else

                    res = 0;

                if (res < 0) {

                    av_log(avctx, AV_LOG_ERROR, "invalid vlc\n");

                    return AVERROR_INVALIDDATA;

                }

                val  = h[0].values[res];

                if(vlc[1].table)

                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);

                else

                    res = 0;

                if (res < 0) {

                    av_log(avctx, AV_LOG_ERROR, "invalid vlc\n");

                    return AVERROR_INVALIDDATA;

                }

                val |= h[1].values[res] << 8;

                pred[0] += sign_extend(val, 16);

                *samples++ = av_clip_int16(pred[0]);

            }

        }

    } else { //8-bit data

        for(i = stereo; i >= 0; i--)

            pred[i] = get_bits(&gb, 8);

        for(i = 0; i <= stereo; i++)

            *samples8++ = pred[i];

        for(; i < unp_size; i++) {

            if(get_bits_left(&gb)<0)

                return AVERROR_INVALIDDATA;

            if(i & stereo){

                if(vlc[1].table)

                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);

                else

                    res = 0;

                if (res < 0) {

                    av_log(avctx, AV_LOG_ERROR, "invalid vlc\n");

                    return AVERROR_INVALIDDATA;

                }

                pred[1] += sign_extend(h[1].values[res], 8);

                *samples8++ = av_clip_uint8(pred[1]);

            } else {

                if(vlc[0].table)

                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);

                else

                    res = 0;

                if (res < 0) {

                    av_log(avctx, AV_LOG_ERROR, "invalid vlc\n");

                    return AVERROR_INVALIDDATA;

                }

                pred[0] += sign_extend(h[0].values[res], 8);

                *samples8++ = av_clip_uint8(pred[0]);

            }

        }

    }



    for(i = 0; i < 4; i++) {

        if(vlc[i].table)

            ff_free_vlc(&vlc[i]);

        av_free(h[i].bits);

        av_free(h[i].lengths);

        av_free(h[i].values);

    }



    *got_frame_ptr   = 1;

    *(AVFrame *)data = s->frame;



    return buf_size;

}
