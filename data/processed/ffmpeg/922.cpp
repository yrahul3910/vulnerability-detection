static void ffmpeg_cleanup(int ret)

{

    int i, j;



    if (do_benchmark) {

        int maxrss = getmaxrss() / 1024;

        printf("bench: maxrss=%ikB\n", maxrss);

    }



    for (i = 0; i < nb_filtergraphs; i++) {

        FilterGraph *fg = filtergraphs[i];

        avfilter_graph_free(&fg->graph);

        for (j = 0; j < fg->nb_inputs; j++) {

            av_freep(&fg->inputs[j]->name);

            av_freep(&fg->inputs[j]);

        }

        av_freep(&fg->inputs);

        for (j = 0; j < fg->nb_outputs; j++) {

            av_freep(&fg->outputs[j]->name);

            av_freep(&fg->outputs[j]);

        }

        av_freep(&fg->outputs);

        av_freep(&fg->graph_desc);



        av_freep(&filtergraphs[i]);

    }

    av_freep(&filtergraphs);



    av_freep(&subtitle_out);



    /* close files */

    for (i = 0; i < nb_output_files; i++) {

        OutputFile *of = output_files[i];

        AVFormatContext *s = of->ctx;

        if (s && s->oformat && !(s->oformat->flags & AVFMT_NOFILE) && s->pb)

            avio_closep(&s->pb);

        avformat_free_context(s);

        av_dict_free(&of->opts);



        av_freep(&output_files[i]);

    }

    for (i = 0; i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];

        AVBitStreamFilterContext *bsfc = ost->bitstream_filters;

        while (bsfc) {

            AVBitStreamFilterContext *next = bsfc->next;

            av_bitstream_filter_close(bsfc);

            bsfc = next;

        }

        ost->bitstream_filters = NULL;

        av_frame_free(&ost->filtered_frame);

        av_frame_free(&ost->last_frame);



        av_parser_close(ost->parser);



        av_freep(&ost->forced_keyframes);

        av_expr_free(ost->forced_keyframes_pexpr);

        av_freep(&ost->avfilter);

        av_freep(&ost->logfile_prefix);



        av_freep(&ost->audio_channels_map);

        ost->audio_channels_mapped = 0;



        avcodec_free_context(&ost->enc_ctx);



        av_freep(&output_streams[i]);

    }

#if HAVE_PTHREADS

    free_input_threads();

#endif

    for (i = 0; i < nb_input_files; i++) {

        avformat_close_input(&input_files[i]->ctx);

        av_freep(&input_files[i]);

    }

    for (i = 0; i < nb_input_streams; i++) {

        InputStream *ist = input_streams[i];



        av_frame_free(&ist->decoded_frame);

        av_frame_free(&ist->filter_frame);

        av_dict_free(&ist->decoder_opts);

        avsubtitle_free(&ist->prev_sub.subtitle);

        av_frame_free(&ist->sub2video.frame);

        av_freep(&ist->filters);

        av_freep(&ist->hwaccel_device);



        avcodec_free_context(&ist->dec_ctx);



        av_freep(&input_streams[i]);

    }



    if (vstats_file)

        fclose(vstats_file);

    av_freep(&vstats_filename);



    av_freep(&input_streams);

    av_freep(&input_files);

    av_freep(&output_streams);

    av_freep(&output_files);



    uninit_opts();



    avformat_network_deinit();



    if (received_sigterm) {

        av_log(NULL, AV_LOG_INFO, "Received signal %d: terminating.\n",

               (int) received_sigterm);

    } else if (ret && transcode_init_done) {

        av_log(NULL, AV_LOG_INFO, "Conversion failed!\n");

    }

    term_exit();

}
